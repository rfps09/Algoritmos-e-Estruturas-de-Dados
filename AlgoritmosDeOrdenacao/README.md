# Explicação dos Algorimos

Obs: eu sempre vou explicar os algoritmos ordenando de maneira crescente, mas para ordenar de maneira decrescente é só pensar o contrário na hora da comparação

# [BubbleSort](https://github.com/rfps09/Algoritmos-e-Estruturas-de-Dados/blob/main/AlgoritmosDeOrdenacao/BubbleSort.cpp)
>Foi o primeiro algoritmo que aprendi e um dos mais fácil de implementar. A ideia do algoritmo se baseia em colocar o maior elemento no final, e para isso faz sucessivas comparações e troca de elementos com o intuito de colocar o maior elemento na possição correta, ou seja, na primeira iteração ele coloca o maior elemento no final, na segunda iteração o segundo maior elemento no final, na terceira iteração o terceio maior elemento no final e assim por diante até ordenar o vetor.

![BubbleSort](/AlgoritmosDeOrdenacao/img/BubbleSort.jpg)

# [SelectionSort](https://github.com/rfps09/Algoritmos-e-Estruturas-de-Dados/blob/main/AlgoritmosDeOrdenacao/SelectionSort.cpp)
>Assim como o bubbleSort é um algoritmo bem simples de implementar e sua ideia é bem intuitiva. A ideia do algoritmo é percorrer o vetor e achar o menor elemento dele (bom, achar o index dele) feito isso nós sabemos que como ele é o menor elemento ele deve ficar na primeira posição, após isso é só procurar o menor elemento nos candidatos restantes e colocar ele na segunda posição do vetor, e assim por diante.

![SelectionSort](/AlgoritmosDeOrdenacao/img/SelectionSort.jpg)

# [InsertionSort](https://github.com/rfps09/Algoritmos-e-Estruturas-de-Dados/blob/main/AlgoritmosDeOrdenacao/InsertionSort.cpp)
>Não diferente do bubbleSort e selectionSort, o insertionSort é um algoritmo bem fácil de implementar. Vou explica-lo diferente da implementação, para melhor entendimento. Bom a ideia dele consiste em "criar" um novo vetor e ir inserindo os elementos do nosso vetor desordenado no nosso "novo" vetor, porém de maneira ordenada, para fazer isso ele sempre compara o elemento que estamos tendando inserir com os elementos já existente no nosso "novo" vetor ordenado, porém ele não precisa necessariamente percorrer todo o vetor ordenado para saber a posição correta da inserção, pois o nosso "novo" vetor está ordenado e isso facilita a identificação da posição correta e isso faz com que o insertionSort seja uma melhor opção ao invés do bubbleSort e selectionSort.

# [ShellSort](https://github.com/rfps09/Algoritmos-e-Estruturas-de-Dados/blob/main/AlgoritmosDeOrdenacao/ShellSort.cpp)
>O shellSort é uma versão melhorada do insertionSort, apesar de no geral o insertionSort ser melhor que o bubbleSort e selectionSort, no pior caso, todos eles são iguais, então o shellSort vem como uma melhoria do insertionSort, para melhorar ele pensando no pior caso, que seria o vetor ordenado de maneira invertida ao que se deseja, a ideia da melhoria é fazer com que os elementos fiquem mais próximos da sua posição ideal, evitando o pior caso do insertionSort, e para isso, o shellSort faz vários insertionSort, porém com uma modificação, ele da saltos nas comparações de elemetentos, e a cada insertionSort modificado que o shellSort roda, ele muda esses saltos, os primeiros saltos são grandes, e o último salto faz com que o shellSort vire um insertionSort padrão, porém no final o vetor provavelmente vai está quase ordenado, e o insertionSort que roda no final, roda perto do melhor caso.

# [QuickSort](https://github.com/rfps09/Algoritmos-e-Estruturas-de-Dados/blob/main/AlgoritmosDeOrdenacao/QuickSort.cpp)
>Em desenvolvimento...

# [MergeSort](https://github.com/rfps09/Algoritmos-e-Estruturas-de-Dados/blob/main/AlgoritmosDeOrdenacao/MergeSort.cpp)
>O primeiro algoritmo eficiente que aprendi. A ideia dele se baseia na famosa ideia de divisão e consquista, bom, inicialmente começamos com um vetor de tamanho N e então a partir disso dividimos esse vetor em 2, criando dois vetores, e repetimos essa ideia em nossos vetores criados, até que surjam vetores de tamanho 1 (bom, nós não criamos de fato esse vetores mas dividimos ele de forma lógica assim), feito isso cada um desses nossos vetores de tamanho 1 está ordenado (pois só tem 1 elemento em cada), agora nós só precisamos unir esses vetores ordenados, porém não podemos unir ele de qualquer jeito, precisamos que o novo vetor resultante da união dos nossos dois vetores ordenados mantenha a ordenação, então como fazemos essa união? para mantermos essa ordenação na hora da união nós vamos criar um novo vetor de tamanho 0 e vamos comparar o primeiro elemento de cada vetor que queremos unir (pois nossos vetores que queremos unir estão ordenados, e o primeiro elemento é o menor do vetor), o menor dentre eles vai ser movido para a primeira posição do nosso novo vetor, e continuamos a comparação até um deles acabar, quando isso acontecer os elementos restantes do outro vetor podem ser adicionados no final do novo vetor (pois os elementos restantes nele estaram ordenados e não tem nenhum elemento no outro vetor, indicando que todos os que sobraram nesse vetor eram maiores), e agora uniremos esse novo vetor com um outro novo vetor de mesmo tamanho, para resultar em um novo vetor de tamanho maior. Fazemos isso até unir dois vetores que resultem em um novo com tamanho N. Para melhor entendimento do algoritmo checar a implementação (a implementação está um pouco diferente da explicação, pois a explicação foi só para melhor entendimento lógico do algoritmo, mas na implementação nem sempre é bom ficar criandos novos vetores na memória).

![MergeSort](/AlgoritmosDeOrdenacao/img/MergeSort.jpg)

# [HeapSort](https://github.com/rfps09/Algoritmos-e-Estruturas-de-Dados/blob/main/AlgoritmosDeOrdenacao/HeapSort.cpp)
>Esse algoritmo usa a ideia da estrutura de dados Heap para ordenar o vetor, um Heap é uma árvoré binária (nem sempre completa, mas quando não completa os nós do último nível estão sempre mais a esquerda), que obece a seguinte propriedade um pai sempre tem valor maior que os filhos, sendo assim a raiz da árvore sempre é o maior elemento, então dado um vetor de tamanho N não ordenado nós transformamos esse vetor num heap, então o heapSort se aproveita disso, ele troca a raiz dessa árvore pela folha de nível mais baixo, e sempre a mais a direita possivel, pois assim o maior elemento fica na ultima posição do vetor, e agora ele reconsidera o tamanho do vetor como sendo N-1 (N sendo o tamanho do vetor atual), porém agora esse "novo" vetor de tamanho N-1 não é um heap, então ele tem que modificar esse vetor para obedecer novamente a propriedade de Heap, e repetir o processo de trocar a raiz com o elemento mais abaixo e a direita, porém ele tem uma vantagem ao modificar esse vetor para transforma-lo em Heap, pois nós sabemos que agora só tem um elemento que não obece a propriedade, que é o primeiro, então só precisamos nos preocupar com ele e com os filhos dele. Repetimos esse processo até ordenar o vetor.

![HeapSort](/AlgoritmosDeOrdenacao/img/HeapSort.jpg)