# Explicação dos Algorimos

Obs: eu sempre vou explicar os algoritmos ordenando de maneira crescente, mas para ordenar de maneira decrescente é só pensar o contrário na hora da comparação

# BubbleSort
    Foi o primeiro algoritmo que aprendi e um dos mais fácil de implementar. A ideia do aklgoritmo se baseia em colocar o maior elemento no final, e para isso faz sucessivas comparações e troca de elementos com o intuito de colocar o maior elemento na possição correta, ou seja, na primeira iteração ele coloca o maior elemento no final, na segunda iteração o segundo maior elemento no final, na terceira iteração o terceio maior elemento no final e assim por diante até ordenar o vetor.

# SelectionSort
    Assim como o bubbleSort é um algoritmo bem simples de implementar e sua ideia é bem intuitiva. A ideia do algoritmo é percorrer o vetor e achar o menor elemento dele (bom, achar o index dele) feito isso nós sabemos que como ele é o menor elemento ele deve ficar na primeira posição, após isso é só procurar o menor elemento nos candidatos restantes e colocar ele na segunda posição do vetor, e assim por diante.

# InsertionSort
    Não diferente do bubbleSort e selectionSort, o insertionSort é um algoritmo bem fácil de implementar. A ideia dele é assumir que um vetor de tamanho N, tem apenas 1 elemento ao invés de N (bom, o vetor de tamanho N pode ter o N valendo 1, mas ai não teria que ordenar, então bom senso ao imaginar esse N), feito isso nós vamos "inserir" o nosso segundo elemento, porém nós não podemos inserir ele em qualquer lugar, devemos inserir ele tal que o elemento anterior seja menor ou igual a ele, e o elemento posterior seja maior que ele ou não "exista", e para fazer isso é só ir comparando com o ultimo elemento do nosso vetor imaginário, pois esse está ordenado, e sempre o último elemento é o maior possível naquele momento, e quando esse elemento que estão tentando "inserir" é maior que um deles é porque aquela é a posição correta, e é só repetir o processo até inserir o ultimo elemento N. Para melhor entendimento checar o código.

# ShellSort
    Em desenvolvimento...

# MergeSort
    O primeiro algoritmo eficiente que aprendi. A ideia dele se baseia na famosa ideia de divisão e consquista, bom, inicialmente começamos com um vetor de tamanho N e então a partir disso dividimos esse vetor em 2, criando dois vetores, e repetimos essa ideia em nossos vetores criados, até que surjam vetores de tamanho 1 (bom, nós não criamos de fato esse vetores mas dividimos ele de forma lógica assim), feito isso cada um desses nossos vetores de tamanho 1 está ordenado (pois só tem 1 elemento em cada), agora nós só precisamos unir esses vetores ordenados, porém não podemos unir ele de qualquer jeito, precisamos que o novo vetor resultante da união dos nossos dois vetores ordenados mantenha a ordenação, então como fazemos essa união? para mantermos essa ordenação na hora da união nós vamos criar um novo vetor de tamanho 0 e vamos comparar o primeiro elemento de cada vetor que queremos unir (pois nossos vetores que queremos unir estão ordenados, e o primeiro elemento é o menor do vetor), o menor dentre eles vai ser movido para a primeira posição do nosso novo vetor, e continuamos a comparação até um deles acabar, quando isso acontecer os elementos restantes do outro vetor podem ser adicionados no final do novo vetor (pois os elementos restantes nele estaram ordenados e não tem nenhum elemento no outro vetor, indicando que todos os que sobraram nesse vetor eram maiores), e agora uniremos esse novo vetor com um outro novo vetor de mesmo tamanho, para resulta em um novo vetor de tamanho maior. Fazemos isso até unir dois vetores que resultem em um novo com tamanho N. Para melhor entendimento do algoritmo checar a implementação (a implementação está um pouco diferente da explicação, pois a explicação foi só para melhor entendimento lógico do algoritmo, mas na implementação nem sempre é bom ficar criandos novos vetores na memória).

# HeapSort
    Esse algoritmo usa a ideia da estrutura de dados Heap para ordenar o vetor, um Heap é uma árvoré binária (nem sempre completa, mas quando não completa os nós do último nível estão sempre mais a esquerda), que obece a seguinte propriedade um pai sempre tem valor maior que os filhos, sendo assim a raiz da árvore sempre é o maior elemento, então dado um vetor de tamanho N não ordenado nós transformamos esse vetor num heap, então o heapSort se aproveita disso, ele troca a raiz dessa árvore pela folha de nível mais baixo, e sempre a mais a direita possivel, pois assim o maior elemento fica na ultima posição do vetor, e agora ele reconsidera o tamanho do vetor como sendo N-1 (N sendo o tamanho do vetor atual), porém agora esse "novo" vetor de tamanho N-1 não é um heap, então ele tem que modificar esse vetor para obedecer novamente a propriedade de Heap, e repetir o processo de trocar a raiz com o elemento mais abaixo e a direita, porém ele tem uma vantagem ao modificar esse vetor para transforma-lo em Heap, pois nós sabemos que agora só tem um elemento que não obece a propriedade, que é o primeiro, então só precisamos nos preocupar com ele e com os filhos dele. Repetimos esse processo até ordenar o vetor.